---
title: "**Identificaci√≥n de marcadores**"
subtitle: "**Bioconductor** para datos transcript√≥micos de c√©lula √∫nica (**scRNA-seq**) -- **CDSB2021**"  
author: 
  - "Yalbi I. Balderas-Mart√≠nez"
date: '`r Sys.Date()`'
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: xaringan-themer.css
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    includes:
      #in_header:
        #- 'gtag.js'
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```

```{r xaringan-themer, include=FALSE}
library(xaringanthemer)
solarized_dark(
    code_font_family = "Fira Code",
    code_font_url    = "https://cdn.rawgit.com/tonsky/FiraCode/1.204/distr/fira_code.css"
)
```

class: inverse

.center[

<a href="https://osca.bioconductor.org/"><img src="https://raw.githubusercontent.com/Bioconductor/OrchestratingSingleCellAnalysis-release/master/images/cover.png" style="width: 30%"/></a>

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.


]

.footnote[Descarga los materiales con `usethis::use_course('comunidadbioinfo/cdsb2021')` o rev√≠salos en l√≠nea via [**comunidadbioinfo.github.io/cdsb2021**](http://comunidadbioinfo.github.io/cdsb2021).]

```{css, echo = FALSE}
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
/* From https://github.com/yihui/xaringan/wiki/Font-Size */
.tiny{
  font-size: 40%
}
/* From https://github.com/yihui/xaringan/wiki/Title-slide */
.title-slide {
  background-image: url(https://raw.githubusercontent.com/Bioconductor/OrchestratingSingleCellAnalysis/master/images/Workflow.png);
  background-size: 33%;
  background-position: 0% 100%
}
```

---

# Diapositivas de Peter Hickey

Ver las diapositivas originales [aqu√≠](https://docs.google.com/presentation/d/18NArqbfeo3Ujo8bcSJTWXirY8N4lEG-T_tFEqlI-uek/edit)

Plantilla desarrollada por: [Leonardo Collado-Torres](http://lcolladotor.github.io/)

---

# Motivaci√≥n 

Ahora que hemos obtenido los cl√∫steres, nos preguntamos, pero qu√© son? (e.g. ¬øqu√© tipo celular es el cl√∫ster 1?)

¬øCu√°les genes est√°n dirigiendo el agrupamiento (e.g., ¬øcu√°les son los genes diferencialmente expresados entre los cl√∫steres 1 y 2?)

Idea: Mirar las diferencias en los perfiles de expresi√≥n de las c√©lulas de los diferentes cl√∫steres

---

class: inverse center middle

# Dataset ilustrativo: PBMC4k 10X sin filtrar

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
library(BiocFileCache)
bfc <- BiocFileCache()
raw.path <- bfcrpath(bfc, file.path(
    "http://cf.10xgenomics.com/samples",
    "cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz"
))
untar(raw.path, exdir = file.path(tempdir(), "pbmc4k"))
```

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
library(DropletUtils)
library(Matrix)
fname <- file.path(tempdir(), "pbmc4k/raw_gene_bc_matrices/GRCh38")
sce.pbmc <- read10xCounts(fname, col.names = TRUE)
```

Dataset "C√©lulas mononucleares humanas de sangre perif√©rica" de 10X Genomics

Descripci√≥n [aqu√≠](https://osca.bioconductor.org/unfiltered-human-pbmcs-10x-genomics.html)

.footnote[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)]

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
# gene-annotation
library(scater)
rownames(sce.pbmc) <- uniquifyFeatureNames(
    rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol
)
library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86,
    keys = rowData(sce.pbmc)$ID,
    column = "SEQNAME", keytype = "GENEID"
)
# cell-detection
set.seed(100)
e.out <- emptyDrops(counts(sce.pbmc))
sce.pbmc <- sce.pbmc[, which(e.out$FDR <= 0.001)]
```

.footnote[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)]

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
# quality-control
stats <- perCellQCMetrics(sce.pbmc,
    subsets = list(Mito = which(location == "MT"))
)
high.mito <- isOutlier(stats$subsets_Mito_percent,
    type = "higher"
)
sce.pbmc <- sce.pbmc[, !high.mito]

# normalization
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, cluster = clusters)
sce.pbmc <- logNormCounts(sce.pbmc)
```

.footnote[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)]

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
# variance modelling
set.seed(1001)
dec.pbmc <- modelGeneVarByPoisson(sce.pbmc)
top.pbmc <- getTopHVGs(dec.pbmc, prop = 0.1)
```

.footnote[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)]

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
# dimensionality-reduction
set.seed(10000)
sce.pbmc <- denoisePCA(sce.pbmc,
    subset.row = top.pbmc,
    technical = dec.pbmc
)

set.seed(100000)
sce.pbmc <- runTSNE(sce.pbmc, dimred = "PCA")

set.seed(1000000)
sce.pbmc <- runUMAP(sce.pbmc, dimred = "PCA")
```

.footnote[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)]

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
# clustering
g <- buildSNNGraph(sce.pbmc, k = 10, use.dimred = "PCA")
clust <- igraph::cluster_walktrap(g)$membership
sce.pbmc$cluster <- factor(clust)
```

.footnote[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)]

---

class: inverse center middle

# Motivaci√≥n - continuaci√≥n

---

# Motivaci√≥n

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
# Is gene 1 associated with the clustering?
plotExpression(sce.pbmc,
    features = rownames(sce.pbmc)[1],
    x = "cluster", colour_by = "cluster"
)
```

---

# Motivaci√≥n

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# Is gene 1 associated with the clustering?
plotExpression(sce.pbmc,
    features = rownames(sce.pbmc)[1],
    x = "cluster", colour_by = "cluster"
)
```

---

# Motivaci√≥n

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
# Is gene 2 associated with the clustering?
plotExpression(sce.pbmc,
    features = rownames(sce.pbmc)[2],
    x = "cluster", colour_by = "cluster"
)
```

---

# Motivaci√≥n

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# Is gene 2 associated with the clustering?
plotExpression(sce.pbmc,
    features = rownames(sce.pbmc)[2],
    x = "cluster", colour_by = "cluster"
)
```

---

# Motivaci√≥n

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
# Is gene 2512 associated with the clustering?
plotExpression(sce.pbmc,
    features = rownames(sce.pbmc)[2512],
    x = "cluster", colour_by = "cluster"
)
```

---

# Motivaci√≥n

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# Is gene 2512 associated with the clustering?
plotExpression(sce.pbmc,
    features = rownames(sce.pbmc)[2512],
    x = "cluster", colour_by = "cluster"
)
```

---

# Motivaci√≥n

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
# Is gene 2512 associated with the clustering?
plotExpression(sce.pbmc,
    features = "CD3E",
    x = "cluster", colour_by = "cluster"
)
```

---

# Motivaci√≥n

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# Is gene 2512 associated with the clustering?
plotExpression(sce.pbmc,
    features = "CD3E",
    x = "cluster", colour_by = "cluster"
)
```

---

# Motivaci√≥n

Ver una gr√°fica como una forma de encontrar los genes marcadores obviamente no nos sirve a gran escala

Necesitamos un m√©todo estad√≠stico para identificar estos genes marcadores 

* üëâ La prueba t de Welch es una opci√≥n obvia para probar las diferencias en la expresi√≥n entre cl√∫steres

---

# Prueba t modificada de Welch pareada

* ‚ûï R√°pidas y buenas propiedades estad√≠sticas para un gran n√∫mero de c√©lulas [(Soneson and Robinson, 2018)](https://www.ncbi.nlm.nih.gov/pubmed/29481549)

* ‚ûï Las comparaciones pareadas proveen un _log-fold change_ para indicar cu√°les cl√∫sterse son distinguidos por cada gen 

* ü§î ¬øPor qu√© no comparar cada cl√∫ster con el promedio de todas las otras c√©lulas?
  - Sensible a la composici√≥n poblacional, una subpoblaci√≥n dominante sola que dirige la selecci√≥n de los marcadores _top_ para cualquier otro cl√∫ster 

---

class: inverse center middle

# Ejemplo ilustrativo: CD3E como gen marcador en el dataset PBMC4k 10X

---

# Pruebas pareadas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
plotExpression(sce.pbmc,
    features = "CD3E",
    x = "cluster", colour_by = "cluster"
)
```

---

# Pruebas pareadas

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(kableExtra)

comparison <- c("1 vs 2", "1 vs 3", "...", "2 vs 1", "...", "18 vs 17")
logFC <- c("1.50", "-0.08", "...", "1.39", "...", "0.11")
Pval <- c("1.7e-198", "0.11", "...", "1.7e-198", "...", "0.46")

paired_tests <- data.frame(comparison, logFC, Pval)

knitr::kable(paired_tests, format = "html") %>%
    kable_styling(
        bootstrap_options = c("striped", "hover"),
        full_width = F,
        font_size = 12,
        position = "left"
    )
```

K = 18 cl√∫steres
K!/K-2)! = 306 comparaciones
* La mitad de ellas son **redundantes**

---

# Combinando comparaciones del gen CD3E para el cl√∫ster 1

"Me interesa saber si el gen CD3 est√° diferencialmente expresado entre el cl√∫ster 1 y .."

- **cualquier** (**any**) otro cl√∫ster = P = 1.3 x 10<sup>-205</sup> (Simes adjusted P-value)
- **todos** (**all**) los otros cl√∫steres = P = 0.11 (Berger's intersection-union test)
- **algunos** (**some**) de los otros cl√∫steres = P = 2.0 x 10<sup>-44</sup> (mediana u otro cuantil, Holm-adjusted P-values)

---

# Extendiendo a todos los genes

```{r, warning=FALSE, message=FALSE}
# scran::pairwiseTTests()
# scran::combineMarkers()
```

- M = 33,694 genes
- ü§ì K x M = 10,310,364 pruebas
- Comparaciones involucrando cl√∫ster 1...
- Comparaciones involucrando cl√∫ster ...
- Comparaciones involucrando cl√∫ster 18

---

class: inverse center middle

# Aplicaci√≥n est√°ndar

---

# Aplicaci√≥n est√°ndar

Para cada cl√∫ster, usar pruebas **t de Welch** para identificar los genes que est√°n diferencialmente expresados entre √©ste y **cualquier** (**any**) otro cl√∫ster 

```{r, warning=FALSE, message=FALSE}
# scran::findMarkers()
library(scran)
markers.pbmc <- findMarkers(sce.pbmc,
    groups = sce.pbmc$cluster,
    test.type = "t", pval.type = "any"
)
```

---

# Aplicaci√≥n est√°ndar

```{r, warning=FALSE, message=FALSE}
chosen <- "9"
interesting <- markers.pbmc[[chosen]]
```

---

# Aplicaci√≥n est√°ndar

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
plotExpression(sce.pbmc, rownames(interesting)[1:4],
    x = "cluster", colour_by = "cluster"
)
```

---

# Aplicaci√≥n est√°ndar

```{r, warning=FALSE, message=FALSE, echo=FALSE}
plotExpression(sce.pbmc, rownames(interesting)[1:4],
    x = "cluster", colour_by = "cluster"
)
```

---

# Aplicaci√≥n est√°ndar

```{r, warning=FALSE, message=FALSE, fig.show="hide"}
best.set <- interesting[interesting$Top <= 6, ]
logFCs <- as.matrix(best.set[, -(1:3)])
colnames(logFCs) <- sub("logFC.", "", colnames(logFCs))

library(pheatmap)
pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```

üëâ Usamos el campo _Top_ para identificar un conjunto de genes que distinguen el cl√∫ster 9 de cualquier otro cl√∫ster

---

# Aplicaci√≥n est√°ndar

```{r, warning=FALSE, message=FALSE, echo=FALSE}
best.set <- interesting[interesting$Top <= 6, ]
logFCs <- as.matrix(best.set[, -(1:3)])
colnames(logFCs) <- sub("logFC.", "", colnames(logFCs))

library(pheatmap)
pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```

---

class: inverse center middle

# Usando el _log-fold change_

---

# Usando el _log-fold change_

Para cada cl√∫ster, usa pruebas t de Welch para identificar los genes que est√°n sobreexpresados entre √©ste y **cualquier** otro cl√∫ster

```{r, warning=FALSE, message=FALSE}
markers.pbmc.up <- findMarkers(sce.pbmc,
    groups = sce.pbmc$cluster,
    test.type = "t", direction = "up", pval.type = "any"
)
interesting.up <- markers.pbmc.up[[chosen]]
```

---

# Usando el _log-fold change_

Para cada cl√∫ster, usa pruebas t de Welch para identificar los genes que est√°n sobreexpresados con un log-fold change (lfc) o al menos 1 entre √©ste y **cualquier** otro cl√∫ster

```{r, warning=FALSE, message=FALSE}
markers.pbmc.up2 <- findMarkers(sce.pbmc,
    groups = sce.pbmc$cluster,
    test.type = "t", direction = "up", lfc = 1, pval.type = "any"
)
interesting.up2 <- markers.pbmc.up2[[chosen]]
```

* üëâ La prueba t tambi√©n nos permite especificar un _log-fold change_ diferente de cero como la hip√≥tesis nula 
* ü§ì Es m√°s riguroso que simplemente filtrar por _log-fold change_ [TREAT](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2654802/)

---

# Usando el _log-fold change_

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
best.set <- interesting.up2[interesting.up2$Top <= 5, ]
logFCs <- as.matrix(best.set[, -(1:3)])
colnames(logFCs) <- sub("logFC.", "", colnames(logFCs))

pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```

* üëâ Los promedios est√°n m√°s centrados en un conjunto de genes marcadores candidatos que est√°n sobreexpresados en el cl√∫ster 9 
* ‚ö†Ô∏è El incremento del rigor no se da sin costo 
* ‚ö†Ô∏è Si el _lfc_ es muy grande podr√≠a descartar genes √∫tiles
	- E.g., un gen sobreexpresado en una proporci√≥n peque√±a de c√©lulas en un cl√∫ster sigue siendo un marcador efectivo si el foco est√° en la especificidad m√°s que en la sensibilidad 
	
---

# Usando el _log-fold change_

```{r, warning=FALSE, message=FALSE, echo=FALSE}
best.set <- interesting.up2[interesting.up2$Top <= 5, ]
logFCs <- as.matrix(best.set[, -(1:3)])
colnames(logFCs) <- sub("logFC.", "", colnames(logFCs))

pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```

---

class: inverse center middle

# Encontrando marcadores espec√≠ficos de cl√∫steres

---

# Encontrando marcadores espec√≠ficos de cl√∫steres

* üëâ Por defecto, `scran::findMarkers()` dar√° un alto rango a genes que est√°n DE en cualquier comparaci√≥n pareada
* ü§î Quiero genes que son espec√≠ficos de cada cl√∫ster
* üëâ T√∫ quieres genes que son DE en todas las comparaciones pareadas

---

# Encontrando marcadores espec√≠ficos de cl√∫steres

Para cada cl√∫ster, usa pruebas t de Welch para identificar genes que est√°n sobreexpresados entre √©ste y **todos** los otros cl√∫steres 

```{r, warning=FALSE, message=FALSE}
markers.pbmc.up3 <- findMarkers(sce.pbmc,
    groups = sce.pbmc$cluster,
    direction = "up", pval.type = "all"
)
interesting.up3 <- markers.pbmc.up3[[chosen]]
```

ü§ì Usa una prueba de uni√≥n-intersecci√≥n para combinar los P-values que es el m√°ximo P-value de todas las comparaciones pareadas 

---

# Pros/cons de los genes marcadores espec√≠ficos de los cl√∫steres

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(kableExtra)

Poblacion <- c("DN(CD4-/CD8-)", "CD4+>", "CD8+>", "DP(CD4+/CD8+)")
Expresion_CD4 <- c("No", "Si", "No", "Si")
Expresion_CD8 <- c("No", "No", "Si", "Si")

poblacion <- data.frame(Poblacion, Expresion_CD4, Expresion_CD8)

knitr::kable(poblacion, format = "html") %>%
    kable_styling(
        bootstrap_options = c("striped", "hover"),
        full_width = F,
        font_size = 12,
        position = "left"
    )
```

---

# Encontrando los genes marcadores espec√≠ficos por cl√∫ster

Para cada cl√∫ster, usa pruebas t de Welch para identificar los genes que est√°n sobreexpresados entre √©ste y **algunos** de los otros cl√∫sters 

```{r, warning=FALSE, message=FALSE}
markers.pbmc.up4 <- findMarkers(sce.pbmc,
    groups = sce.pbmc$cluster,
    direction = "up", pval.type = "some"
)
interesting.up4 <- markers.pbmc.up4[[chosen]]
```

* üëâ Para cuando `pval.type="all"` es muy estricto todav√≠a `pval.type="any"` es muy generoso
* ü§ì Aplica la correcci√≥n Holm-Bonferroni a los P-values y toma el mejor valor de en medio como el P-value combinado
* ‚ö†Ô∏è Perder√°s algunas garant√≠as ofrecidas por los otros m√©todos 

---

class: inverse center middle

# Pruebas alternas

---

# Motivaci√≥n

La prueba t no es la √∫nica forma de comparar dos grupos de mediciones

* ü§î Quiero una prueba que pueda ser usada perfectamente para distinguir dos cl√∫steres uno del otro
- üëâ Prueba de rangos Wilcoxon

* ü§î Quiero identificar genes que son expresados m√°s frecuentemente en un cl√∫ster que en otro
- üëâ Prueba Binomial

---

# Prueba de rangos de Wilcoxon

Eval√∫a directamente la separaci√≥n entre la distribuci√≥n de la expresi√≥n de los diferentes cl√∫steres

* ü§ì Es proporcional al √°rea bajo la curva (AUC), que es la probabilidad de que una c√©lula al azar de un cl√∫ster tenga mayor que expresi√≥n que una c√©lula al azar de otro cl√∫ster

* üëâ AUCs de 1 o 0 indican que los dos cl√∫steres tienen distribuciones de expresi√≥n separadas 

* ü§ì Tambi√©n se conoce como prueba Wilcoxon-Mann-Whitney (WMW)

---

# Prueba de rangos de Wilcoxon

Para cada cl√∫ster, usa la prueba de rangos de Wilcoxon para identificar genes que est√°n sobreexpresados entre √©ste y **cualquier** otro cl√∫ster 

```{r, warning=FALSE, message=FALSE}
markers.pbmc.wmw <- findMarkers(sce.pbmc,
    groups = sce.pbmc$cluster, test.type = "wilcox",
    direction = "up", pval.type = "any"
)
interesting.wmw <- markers.pbmc.wmw[[chosen]]
```

---

# Prueba de rangos de Wilcoxon

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
best.set <- interesting.wmw[interesting.wmw$Top <= 5, ]
AUCs <- as.matrix(best.set[, -(1:3)])
colnames(AUCs) <- sub("AUC.", "", colnames(AUCs))

pheatmap(AUCs,
    breaks = seq(0, 1, length.out = 21),
    color = viridis::viridis(21)
)
```

---

# Prueba de rangos de Wilcoxon

```{r, warning=FALSE, message=FALSE, echo=FALSE}
pheatmap(AUCs,
    breaks = seq(0, 1, length.out = 21),
    color = viridis::viridis(21)
)
```

---

# Resumen de la prueba de rangos de Wilcoxon

* ‚ûï Ofrece directamente la propiedad deseable de un gen marcador (i.e. que el gen distinga perfectamente entre dos cl√∫steres)
* ‚ûï Es sim√©trico con respecto a las diferencias en el tama√±o de los grupos comparados
* ‚ûñ Es mucho m√°s lento comparado con la prueba t (aunque esto en general no es un problema en la pr√°ctica)

---

# Prueba binomial

* Es una prueba que identifica los genes que difieren en la proporci√≥n de c√©lulas que se expresan entre cl√∫steres 
* Una definici√≥n mucho m√°s estricta de genes marcadores 

* ü§ì Convierte la expresi√≥n en una medida binaria de presencia/ausencia, por lo que toda la informaci√≥n cuantitativa es ignorada 
- Desde una perspectiva pr√°ctica, puede ser m√°s f√°cil para validar 

---

# Prueba binomial

Para cada cl√∫ster, usa la prueba Binomial para identificar genes que est√°n m√°s frecuentemente expresados (sobreexpresados) en comparaci√≥n con cualquier otro cl√∫ster 

```{r, warning=FALSE, message=FALSE}
markers.pbmc.binom <- findMarkers(sce.pbmc,
    groups = sce.pbmc$cluster, test.type = "binom",
    direction = "up", pval.type = "any"
)
interesting.binom <- markers.pbmc.binom[[chosen]]
```

* ü§ì El efecto en el tama√±o se reporta como el _log-fold change_ en la proporci√≥n de las c√©lulas que se expresan entre cl√∫steres 
* üëâ _Log-fold changes_ grandes positivos, indican que el gen est√° m√°s frecuentemente expresado en un cl√∫ster comparado con otro

---

# Prueba binomial

```{r, warning=FALSE, message=FALSE, fig.show='hide'}
top.genes <- head(rownames(interesting.binom))
plotExpression(sce.pbmc, x = "cluster", features = top.genes)
```

---

# Prueba binomial

```{r, warning=FALSE, message=FALSE, echo=FALSE}
top.genes <- head(rownames(interesting.binom))
plotExpression(sce.pbmc, x = "cluster", features = top.genes)
```

---

# Resumen de la prueba binomial

* La prueba Binomial no toma en cuenta la normalizaci√≥n

* ‚ûï Produce genes marcadores que pueden ser m√°s f√°ciles de validar

* ‚ûñ Ser m√°s estricto puede llevar a la p√©rdida de buenos marcadores candidatos  

---

# M√©todos de expresi√≥n diferencial personalizados

* ü§î ¬øPor qu√© no usar edgeR/DESeq2/limma-voom u otros m√©todos personalizados (e.g., MAST)?
* üëâ Claro que puedes! [Checa OSCA](https://osca.bioconductor.org/marker-detection.html#using-custom-de-methods)

* üëâ Pero √©stos son tal vez algo exagerados para identificar genes marcadores
* ü§ì Las c√©lulas son nuestras "r√©plicas" para el prop√≥sito de identificar genes marcadores
* ü§ì edgeR/DESeq2/limma-voom hacen asunciones m√°s fuertes acerca de los datos que es m√°s probable que no se cumplan para c√©lulas individuales en scRNA-seq

---

class: inverse center middle

# Problemas estad√≠sticos

---

# Invalidez de P-values

Todas las estrategias de DE para detectar genes marcadores entre cl√∫steres son estad√≠sticamente defectuosas de alguna manera

* ü§ì "Dragado de datos": El an√°lisis DE se realiza usando los mismos datos usados para obtener los cl√∫steres 

* üëâ Las pruebas para genes DE entre cl√∫steres producir√° inevitablemente algunos resultados significativos y as√≠ es como los cl√∫steres ser√°n definidos!

---

# Invalidez de P-values

üëâ A√∫n cuando los P-values son defectuosos, el efecto no es muy da√±ino para la detecci√≥n de genes ya que los P-values solo son usados para los rangos

ü§ì No se pueden usar P-values para definir "diferencias significativas" entre los cl√∫steres con respecto a un umbral de la tasa de error 

---

# Naturaleza de la replicaci√≥n

üëâ Idealmente, validar algunos de los marcadores con una poblaci√≥n de c√©lulas independientes (y idealmente usando una t√©cnica diferente, e.g., hibridaci√≥n fluorescente _in situ_ o qPCR)

---

class: inverse center middle

# Comentarios adicionales

---

# Comentarios adicionales

* üëâ La estrategia de an√°lisis DE es que los marcadores son definidos relativo a subpoblaciones en el mismo dataset 
* üëâ Si un gen se expresa uniformemente a trav√©s de la poblaci√≥n no servir√° como un marcador
- e.g., los marcadores de las c√©lulas T no ser√°n detectados si solamente hay c√©lulas T en los datos
- usualmente no es un problema, ya que tenemos idea de las c√©lulas que se capturaron
* üëâ Existen m√©todos de machine learning para hacer la identificaci√≥n de los genes marcadores, pero la humilde prueba t sigue siendo muy buena

---

class: inverse center middle

# Resumen y recomendaciones

---

# Resumen y recomendaciones

* üëâ Crea m√∫ltiples listas de genes marcadores con diferentes niveles de rigor
* üëâ La forma m√°s simple de interpretar los genes marcadores es que son los sobreexpresados de "forma √∫nica", o son "genes espec√≠ficos de cl√∫steres", especialmente si queremos imponer un _log-fold change_ m√≠nimo
* üëâ Puedes requerir hacer una identificaci√≥n de genes marcadores m√°s enfocada, e.g., subset de los datos de solo 2 cl√∫steres de inter√©s y entonces correr `scran::findMarkers()`

---

La presentaci√≥n fue hecha con el paquete de R [**xaringan**](https://github.com/yihui/xaringan) y configurada con [**xaringanthemer**](https://github.com/gadenbuie/xaringanthemer).

Este curso est√° basado en el libro [**Orchestrating Single Cell Analysis with Bioconductor**](https://osca.bioconductor.org/) de [Aaron Lun](https://www.linkedin.com/in/aaron-lun-869b5894/), [Robert Amezquita](https://robertamezquita.github.io/), [Stephanie Hicks](https://www.stephaniehicks.com/) y [Raphael Gottardo](http://rglab.org), adem√°s del [**curso de scRNA-seq para WEHI**](https://drive.google.com/drive/folders/1cn5d-Ey7-kkMiex8-74qxvxtCQT6o72h) creado por [Peter Hickey](https://www.peterhickey.org/).

Puedes encontrar los archivos para este taller en  [comunidadbioinfo/cdsb2021](https://github.com/comunidadbioinfo/cdsb2021). 

Instructora: [**Yalbi I. Balderas-Mart√≠nez**](http://Yalbibalderas.github.io/).

.footnote[Descarga los materiales con `usethis::use_course('comunidadbioinfo/cdsb2021')` o rev√≠salos en l√≠nea v√≠a [**comunidadbioinfo.github.io/cdsb2021**](http://comunidadbioinfo.github.io/cdsb2021).]

---

# Detalles de la sesi√≥n de R


.scroll-output[
.tiny[

```{r 'reproducibility', cache = TRUE, dependson=knitr::all_labels()}
options(width = 120)
sessioninfo::session_info()
```

]]







