---
title: "**Selecci√≥n de genes**"
subtitle: "**Bioconductor** para datos transcript√≥micos de c√©lula √∫nica (**scRNA-seq**) -- **CDSB2021**"  
author: 
  - "Yalbi I. Balderas-Mart√≠nez"
date: '`r Sys.Date()`'
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: xaringan-themer.css
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    includes:
      #in_header:
        #- 'gtag.js'
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```

```{r xaringan-themer, include=FALSE}
library(xaringanthemer)
solarized_dark(
    code_font_family = "Fira Code",
    code_font_url    = "https://cdn.rawgit.com/tonsky/FiraCode/1.204/distr/fira_code.css"
)
```

class: inverse

.center[

<a href="https://osca.bioconductor.org/"><img src="https://raw.githubusercontent.com/Bioconductor/OrchestratingSingleCellAnalysis-release/master/images/cover.png" style="width: 30%"/></a>

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.


]

.footnote[Descarga los materiales con `usethis::use_course('comunidadbioinfo/cdsb2021')` o rev√≠salos en l√≠nea via [**comunidadbioinfo.github.io/cdsb2021**](http://comunidadbioinfo.github.io/cdsb2021).]

```{css, echo = FALSE}
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
/* From https://github.com/yihui/xaringan/wiki/Font-Size */
.tiny{
  font-size: 40%
}
/* From https://github.com/yihui/xaringan/wiki/Title-slide */
.title-slide {
  background-image: url(https://raw.githubusercontent.com/Bioconductor/OrchestratingSingleCellAnalysis/master/images/Workflow.png);
  background-size: 33%;
  background-position: 0% 100%
}
```

---

# Diapositivas de Peter Hickey

Ver las diapositivas originales [aqu√≠](https://docs.google.com/presentation/d/19J2FyjKlBQdAkku4Oa6UZ6SA-Y4P7AEKCRIbEQWA9ho/edit#slide=id.ga100bba375887aa_0)

Plantilla desarrollada por: [Leonardo Collado-Torres](http://lcolladotor.github.io/)

---

# Motivaci√≥n

Usualmente usamos datos scRNA-seq para caracterizar la heterogeneidad entre c√©lulas

Para hacer esto, usamos m√©todos como el clustering y la reducci√≥n de dimensionalidad

Esto involucra resumir las diferencias por gen en una sola medida de (dis)similitud entre un par de c√©lulas

**¬øCu√°les genes deber√≠amos usar para calcular esta medida de (dis)similitud?**

---

# Selecci√≥n de _features_ (genes)

La elecci√≥n de los _features_ tiene un mayor impacto en qu√© tan similares decidimos que son las c√©lulas 

* ‚ûï _Features_ que contienen informaci√≥n √∫til biol√≥gica 
* ‚ûñ _Features_ que contienen ruido aleatorio
* üëâ Efectos laterales al reducir la dimensionalidad de los datos 

Deseamos seleccionar los **genes altamente variables** (High Variable Genes **HVGs**). Genes con una variaci√≥n incrementada en comparaci√≥n con otros genes que est√°n siendo afectados por ruido t√©cnico u otra variaci√≥n biol√≥gica que no es de nuestro inter√©s.

---
class: inverse center middle

# Dataset ilustrativo: PBMC4k 10X sin filtrar

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
library(BiocFileCache)
bfc <- BiocFileCache()
raw.path <- bfcrpath(bfc, file.path(
    "http://cf.10xgenomics.com/samples",
    "cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz"
))
untar(raw.path, exdir = file.path(tempdir(), "pbmc4k"))
```

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
library(DropletUtils)
library(Matrix)
fname <- file.path(tempdir(), "pbmc4k/raw_gene_bc_matrices/GRCh38")
sce.pbmc <- read10xCounts(fname, col.names = TRUE)
```

Dataset "C√©lulas mononucleares humanas de sangre perif√©rica" de 10X Genomics

Descripci√≥n [aqu√≠](https://osca.bioconductor.org/unfiltered-human-pbmcs-10x-genomics.html)

.footnote[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)]

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
# gene-annotation
library(scater)
rownames(sce.pbmc) <- uniquifyFeatureNames(
    rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol
)
library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86,
    keys = rowData(sce.pbmc)$ID,
    column = "SEQNAME", keytype = "GENEID"
)
# cell-detection
set.seed(100)
e.out <- emptyDrops(counts(sce.pbmc))
sce.pbmc <- sce.pbmc[, which(e.out$FDR <= 0.001)]
```

.footnote[Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)]

---

# Dataset ilustrativo: PBMC4k 10X sin filtrar

```{r, warning=FALSE, message=FALSE}
# quality-control
stats <- perCellQCMetrics(sce.pbmc,
    subsets = list(Mito = which(location == "MT"))
)
high.mito <- isOutlier(stats$subsets_Mito_percent,
    type = "higher"
)
sce.pbmc <- sce.pbmc[, !high.mito]
# normalization
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, cluster = clusters)
sce.pbmc <- logNormCounts(sce.pbmc)
```

---

class: inverse center middle

# Preguntas de repaso

* ¬øC√≥mo determinamos cu√°les eran los genes mitocondriales?
* ¬øC√≥mo decidimos filtrar las c√©lulas
* ¬øPuedes explicar c√≥mo normalizamos los datos?

---

class: inverse center middle

# Dataset ilustrativo: 416B

---

# Dataset ilustrativo: 416B

```{r, warning=FALSE, message=FALSE}
library(scRNAseq)
sce.416b <- LunSpikeInData(which="416b") 
sce.416b$block <- factor(sce.416b$block)
```

L√≠nea celular de c√©lulas mieloides progenitoras inmortalizadas de rat√≥n usando SmartSeq2
[https://osca.bioconductor.org/lun-416b-cell-line-smart-seq2.html](https://osca.bioconductor.org/lun-416b-cell-line-smart-seq2.html)

.footnote[Lun, A. T. L., Calero-Nieto, F. J., Haim-Vilmovsky, L., G√∂ttgens, B. & Marioni, J. C. Assessing the reliability of spike-in normalization for analyses of single-cell RNA sequencing data. Genome Res. 27, 1795‚Äì1806 (2017))]

---

# Dataset ilustrativo: 416B

```{r, warning=FALSE, message=FALSE}
# gene-annotation
library(AnnotationHub)
ens.mm.v97 <- AnnotationHub()[["AH73905"]]
rowData(sce.416b)$ENSEMBL <- rownames(sce.416b)
rowData(sce.416b)$SYMBOL <- mapIds(ens.mm.v97, 
  keys=rownames(sce.416b),
  keytype="GENEID", column="SYMBOL")
rowData(sce.416b)$SEQNAME <- mapIds(ens.mm.v97,
  keys=rownames(sce.416b),
  keytype="GENEID", column="SEQNAME")
library(scater)
rownames(sce.416b) <- uniquifyFeatureNames(rowData(sce.416b)$ENSEMBL, 
  rowData(sce.416b)$SYMBOL)
```

.footnote[Lun, A. T. L., Calero-Nieto, F. J., Haim-Vilmovsky, L., G√∂ttgens, B. & Marioni, J. C. Assessing the reliability of spike-in normalization for analyses of single-cell RNA sequencing data. Genome Res. 27, 1795‚Äì1806 (2017))]

---

# Dataset ilustrativo: 416B

```{r, warning=FALSE, message=FALSE}
# quality-control
mito <- which(rowData(sce.416b)$SEQNAME=="MT")
stats <- perCellQCMetrics(sce.416b, subsets=list(Mt=mito))
qc <- quickPerCellQC(stats,
  percent_subsets=c("subsets_Mt_percent", "altexps_ERCC_percent"),
  batch=sce.416b$block)
sce.416b <- sce.416b[,!qc$discard]

# normalization
library(scran)
sce.416b <- computeSumFactors(sce.416b)
sce.416b <- logNormCounts(sce.416b)
```

.footnote[Lun, A. T. L., Calero-Nieto, F. J., Haim-Vilmovsky, L., G√∂ttgens, B. & Marioni, J. C. Assessing the reliability of spike-in normalization for analyses of single-cell RNA sequencing data. Genome Res. 27, 1795‚Äì1806 (2017))]

---

class: inverse center middle

# Preguntas de repaso

* ¬øC√≥mo determinamos cu√°les eran los genes mitocondriales?
* ¬øC√≥mo decidimos filtrar las c√©lulas
* ¬øPuedes explicar c√≥mo normalizamos los datos?

---

class: inverse center middle

# Cuantificando la varianza por gen

---

# Varianza de los _log-counts_

El enfoque m√°s simple para cuantificar la variaci√≥n _per-feature_ es simplemente calcular la varianza de los _log-counts_

* ‚ûï Selecci√≥n del _feature_  basado en los _log-counts_ (que ser√°n usadas en los an√°lisis m√°s adelante)
* ‚ö†Ô∏è La transformaci√≥n log no logra la estabilizaci√≥n de la varianza perfecta, as√≠ que se requiere modelar la relaci√≥n de la varianza-media de los _features_.

---

# Varianza de los _log-counts_

### Enfoque simple:
1. Calcular la varianza de los _log-counts_ para cada gen (ignorando grupos experimentales)
2. Ordenar los genes del m√°s-al-menos variable

### Un enfoque m√°s sofisticado:
1. Calcular la varianza de los _log-counts_ para cada gen (ignorando grupos experimentales)
2. Modelar la relaci√≥n entre la media y la varianza de los _log-counts_ para estimar la variaci√≥n _t√©cnica_
3. Estimar la varianza _biol√≥gica_ sustrayendo la varianza _t√©cnica_ de la varianza total
4. Ordenar los genes de la variable de mayor-a-menor biol√≥gicamente

---

# Varianza de los _log-counts_

````{r, warning=FALSE, message=FALSE}
library(scran)
dec.pbmc <- modelGeneVar(sce.pbmc)
```

* ü§ì El supuesto es que a cualquier abundancia dada, la abundancia de los perfiles de expresi√≥n de la mayor√≠a de los genes est√°n dominados por el ruido aleatorio _t√©cnico_
* ü§ì Por lo consiguiente, una tendencia representa un estimado del ruido t√©cnico como una funci√≥n de la abundancia
* ü§ì Podemos entonces descomponer la varianza total de cada gen en un componente _t√©cnico_ y uno _biol√≥gico_ 
* ü§ì Genes con una gran varianza _biol√≥gica_ son considerados interesantes 

---

# Varianza de los _log-counts_

```{r, warning=FALSE, message=FALSE, fig.show="hide"}
# Visualizing the fit - relaci√≥n entre la media y la varianza
fit.pbmc <- metadata(dec.pbmc)
plot(fit.pbmc$mean, fit.pbmc$var,
    xlab = "Mean of log-expression",
    ylab = "Variance of log-expression"
)
curve(fit.pbmc$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)
```

---

# Varianza de los _log-counts_

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# Visualizing the fit
fit.pbmc <- metadata(dec.pbmc)
plot(fit.pbmc$mean, fit.pbmc$var,
    xlab = "Mean of log-expression",
    ylab = "Variance of log-expression"
)
curve(fit.pbmc$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)
```

---

# Varianza de los _log-counts_

```{r, warning=FALSE, message=FALSE}
# Ordering by largest 'biological' variation to
# identify most interesting genes
dec.pbmc[order(dec.pbmc$bio, decreasing = TRUE), ]
```

---

# Coeficiente de variaci√≥n de las cuentas

El coeficiente de variaci√≥n de las cuentas al cuadrado (CV<sup>2</sup>) es una alternativa a la varianza de los _log-counts_

* üëâ Se calcula usando las cuentas en lugar de los _log-counts_

* ü§ì CV es el _ratio_ de la desviaci√≥n est√°ndar a la media y est√° muy relacionada con el par√°metro de _dispersi√≥n_ de la distribuci√≥n binomial negativa usada en edgeR y DESeq2

---

# Coeficiente de variaci√≥n

```{r, warning=FALSE, message=FALSE}
dec.cv2.pbmc <- modelGeneCV2(sce.pbmc)
```

* ü§ì Modela la relaci√≥n de la media de la varianza cuando se considera la relevancia de cada gen
* ü§ì Asume que la mayor√≠a de los genes contienen ruido aleatorio y que la tendencia captura la mayor√≠a de la variaci√≥n t√©cnica 
* ü§ì Genes con un gran CV<sup>2</sup> que se desv√≠an fuertemente de la tendencia es probable que representen genes afectados por la estructura biol√≥gica 
* ü§ì Usa la tasa (en lugar de la diferencia) del CV<sup>2</sup> a la tendencia

---

# Coeficiente de variaci√≥n

```{r, warning=FALSE, message=FALSE, fig.show="hide"}
# Visualizing the fit
fit.cv2.pbmc <- metadata(dec.cv2.pbmc)
plot(fit.cv2.pbmc$mean, fit.cv2.pbmc$cv2,
    log = "xy"
)
curve(fit.cv2.pbmc$trend(x),
    col = "dodgerblue",
    add = TRUE, lwd = 2
)
```

---

# Coeficiente de variaci√≥n

```{r, warning=FALSE, message=FALSE, echo = FALSE}
# Visualizing the fit
fit.cv2.pbmc <- metadata(dec.cv2.pbmc)
plot(fit.cv2.pbmc$mean, fit.cv2.pbmc$cv2,
    log = "xy"
)
curve(fit.cv2.pbmc$trend(x),
    col = "dodgerblue",
    add = TRUE, lwd = 2
)
```

---

# Coeficiente de variaci√≥n

```{r, warning=FALSE, message=FALSE}
# Ordering by largest CV2 to identify most interesting genes
dec.cv2.pbmc[order(dec.cv2.pbmc$ratio,
    decreasing = TRUE
), ]
```

---

# La varianza de los _log-counts_ vs coeficiente de variaci√≥n

**Generalmente se usa la varianza de los _log-counts_** 

* Ambas son medidas efectivas para cuantificar la variaci√≥n en la expresi√≥n g√©nica 
* CV<sup>2</sup> tiende a tener otorgar rangos altos a genes bajos niveles de expresi√≥n (HGVs) 
	- √âstos son dirigidos por una sobreregulaci√≥n en subpoblaciones raras 
  - Puede asignar un alto rango a genes que no son de nuestro inter√©s con varianza baja absoluta	
* La variaci√≥n descrita por el CV<sup>2</sup> de las cuentas es menos relevante para los procedimientos que operan en los _log-counts_

---

class: inverse center middle

# Cuantificando el ruido t√©cnico

---

# Cuantificando el ruido t√©cnico

* Previamente, ajustamos una l√≠nea de tendencia a todos los genes end√≥genos y asumimos que la mayor√≠a de los genes no est√°n dominados por ruido t√©cnico

* En la pr√°ctica, todos los genes expresados tienen alg√∫n nivel de variabilidad biol√≥gica diferente de cero (e.g., transcriptional bursting)

* Esto sugiere que nuestros estimados de los componentes t√©cnicos estar√°n inflados probablemente

---

# Cuantificando el ruido t√©cnico

* üëâ Es mejor que pensemos estos estimados como una variaci√≥n _t√©cnica_ m√°s la variaci√≥n biol√≥gica que no es interesante

* ü§î Pero que tal si un grupo de genes a una abundancia particular es afectado por un proceso biol√≥gico?
E.g., fuerte sobre regulaci√≥n de genes espec√≠ficos de un tipo celular podr√≠an conllevar a un enriquecimiento de HVGs en abundancias altas. Esto inflar√≠a la tendencia y compromete la detecci√≥n de los genes relevantes

**¬øC√≥mo podemos evitar este problema?**

---

# ¬øC√≥mo podemos evitar este problema y mejor estimar la variaci√≥n t√©cnica?

Podemos revisar dos enfoques:
1. Cuando tenemos spike-ins
2. Cuando no tenemos spike-ins 

---

# En la presencia de spike-ins

```{r, warning=FALSE, message=FALSE}
dec.spike.416b <- modelGeneVarWithSpikes(sce.416b, 
  "ERCC")
# Ordering by most interesting genes for 
# inspection.
dec.spike.416b[order(dec.spike.416b$bio, 
  decreasing=TRUE),]
```

üëâ Ajusta la tendencia solo con los spike-ins (que deber√≠an estar afectados solamente por variaci√≥n t√©cnica)

---

# En la presencia de spike-ins

```{r, warning=FALSE, message=FALSE}
plot(dec.spike.416b$mean, dec.spike.416b$total,
  xlab="Mean of log-expression",
  ylab="Variance of log-expression")
fit.spike.416b <- metadata(dec.spike.416b)
points(fit.spike.416b$mean, fit.spike.416b$var, 
  col="red", pch=16)
curve(fit.spike.416b$trend(x), col="dodgerblue", 
  add=TRUE, lwd=2)
```

---

# En la ausencia de spike-ins

```{r, warning=FALSE, message=FALSE}
set.seed(0010101)
dec.pois.pbmc <- modelGeneVarByPoisson(sce.pbmc)
# Ordering by most interesting genes for inspection.
dec.pois.pbmc[order(dec.pois.pbmc$bio,decreasing=TRUE),]
```

* üëâ Realiza algunas asunciones estad√≠sticas acerca del ruido
* ü§ì Las cuentas UMI t√≠picamente muestran una variaci√≥n cercana a Poisson si solo consideramos ruido t√©cnico de la preparaci√≥n de las librer√≠as y la secuenciaci√≥n 
* ‚ö†Ô∏è modelGeneVarByPoisson() realiza simulaciones, por lo que necesitamos ‚Äúajustar la ‚Äúsemilla‚Äù para obtener resultados reproducibles
* ü§ì modelGeneVarByPoisson() pueden tambi√©n simular una variaci√≥n binomial negativa (variaci√≥n de Poisson sobredispersada)

---

# En la ausencia de spike-ins

```{r, warning=FALSE, message=FALSE}
plot(dec.pois.pbmc$mean, dec.pois.pbmc$total, 
  pch=16, xlab="Mean of log-expression",
  ylab="Variance of log-expression")
curve(metadata(dec.pois.pbmc)$trend(x),
  col="dodgerblue", add=TRUE)
```

ü§ì La l√≠nea de tendencia basada puramente en ruido t√©cnico tiende a producir componentes ‚Äúbiol√≥gicos‚Äù m√°s grandes por los genes altamente expresados, que frecuentemente incluyen los genes ‚Äúhouse-keeping‚Äù
ü§î Necesitas considerar si tales genes son ‚Äúinteresantes‚Äù o no en tu dataset de inter√©s

---

La presentaci√≥n fue hecha con el paquete de R [**xaringan**](https://github.com/yihui/xaringan) y configurada con [**xaringanthemer**](https://github.com/gadenbuie/xaringanthemer).

Este curso est√° basado en el libro [**Orchestrating Single Cell Analysis with Bioconductor**](https://osca.bioconductor.org/) de [Aaron Lun](https://www.linkedin.com/in/aaron-lun-869b5894/), [Robert Amezquita](https://robertamezquita.github.io/), [Stephanie Hicks](https://www.stephaniehicks.com/) y [Raphael Gottardo](http://rglab.org), adem√°s del [**curso de scRNA-seq para WEHI**](https://drive.google.com/drive/folders/1cn5d-Ey7-kkMiex8-74qxvxtCQT6o72h) creado por [Peter Hickey](https://www.peterhickey.org/).

Puedes encontrar los archivos para este taller en  [comunidadbioinfo/cdsb2021](https://github.com/comunidadbioinfo/cdsb2021). 

Instructora: [**Yalbi I. Balderas-Mart√≠nez**](http://Yalbibalderas.github.io/).

.footnote[Descarga los materiales con `usethis::use_course('comunidadbioinfo/cdsb2021')` o rev√≠salos en l√≠nea v√≠a [**comunidadbioinfo.github.io/cdsb2021**](http://comunidadbioinfo.github.io/cdsb2021).]

---

# Detalles de la sesi√≥n de R


.scroll-output[
.tiny[

```{r 'reproducibility', cache = TRUE, dependson=knitr::all_labels()}
options(width = 120)
sessioninfo::session_info()
```

]]
