# Reducci??n de dimensiones

Instructora: [Laura G??mez-Romero](https://comunidadbioinfo.github.io/es/authors/lgomez/)

## Diapositivas de Peter Hickey

Contenido adaptado de: [aqu??](https://docs.google.com/presentation/d/12CjvQ1beZVeCcMQqD6ptzd9YUHbHOksvy3lt_rvWyRs/edit)

## Motivaci??n

El siguiente paso en el an??lisis de scRNA-seq usualmente consiste en identificar grupos de c??lulas "similares"

Por ejemplo: un an??lisis de clustering busca identificar c??lulas con un perfil transcript??mico similar al calcular distancias entre ellas

Si tuvi??ramos un dataset con dos genes podr??amos hacer una gr??fica de dos dimensiones para identificar clusters de c??lulas

<div>
<p style = 'text-align:center;'>
<img src="img/cluster.gif" width="200px">
</p>
</div>


Pero... tenemos decenas de miles de genes : **Reducci??n de dimensionalidad**

## Reducci??n de dimensionalidad

Es poible porque la expresi??n de diferentes genes estar?? correlacionada si estos genes son afectados por el mismo proceso biol??gico.

Por lo tanto, no necesitamos almacenar informaci??n independiente para genes individuales. Podemos comprimir m??ltiples "features" (genes) en una ??nica dimensi??n.

**Ventajas:**

- Reduce trabajo computacional en an??lisis posteriores
- Reduce el ruido al "promediar" m??tiples genes obteniendo una representaci??n m??s precisa de los patrones en los datos
- Permite una graficaci??n efectiva en dos dimensiones

## Dataset ilustrativo: Zeisel


```{r, warning=FALSE, message=FALSE}
library(scRNAseq)
sce.zeisel <- ZeiselBrainData(ensembl = TRUE)

# Estos datos contienen tipos celulares previamente anotados
table(sce.zeisel$level1class)
```

Estudio de tipos celulares en el cerebro de rat??n (oligodendrocitos, microglia, neuronas, etc) procesados con el sistema STRT-seq (similar a CEL-Seq)

Descripci??n [aqu??](https://osca.bioconductor.org/zeisel-mouse-brain-strt-seq.html)

*Zeisel, A. et al. Brain structure. Cell types in the mouse cortex and hippocampus revealed by single-cell RNA-seq. Science 347, 1138-1142 (2015)*

```{r , warning=FALSE, message=FALSE}
# Quality control
# Descartar celulas con alto contenido mitocondrial o con alto porcentaje de spike-ins
library(scater)
is.mito <- which(rowData(sce.zeisel)$featureType == "mito")
stats <- perCellQCMetrics(sce.zeisel,
    subsets = list(Mt = is.mito)
)
qc <- quickPerCellQC(stats,
    percent_subsets = c("altexps_ERCC_percent", "subsets_Mt_percent")
)
sce.zeisel <- sce.zeisel[, !qc$discard]
```

```{r , warning=FALSE, message=FALSE}
# normalization
# encontramos unos clusters r??pidos para las c??lulas y usamos esa informaci??n para calcular los factores de tama??o
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.zeisel)
sce.zeisel <- computeSumFactors(sce.zeisel,
    cluster = clusters
)
sce.zeisel <- logNormCounts(sce.zeisel)
```


```{r , warning=FALSE, message=FALSE}
# variance-modelling
dec.zeisel <- modelGeneVarWithSpikes(
    sce.zeisel,
    "ERCC"
)
top.zeisel <- getTopHVGs(dec.zeisel, n = 2000)
```

- ??C??mo se est?? modelando la relaci??n media varianza?
- ??C??mo se est??n obteniendo los HGVs?


## Dataset ilustrativo: 10x PBMC4k no filtradas


```{r , warning=FALSE, message=FALSE}
library(BiocFileCache)
bfc <- BiocFileCache()
raw.path <- bfcrpath(bfc, file.path(
    "http://cf.10xgenomics.com/samples",
    "cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz"
))
untar(raw.path, exdir = file.path(tempdir(), "pbmc4k"))
```

```{r , warning=FALSE, message=FALSE}
library(DropletUtils)
library(Matrix)
fname <- file.path(tempdir(), "pbmc4k/raw_gene_bc_matrices/GRCh38")
sce.pbmc <- read10xCounts(fname, col.names = TRUE)
```

Dataset "C??lulas mononucleares humanas de sangre perif??rica" de 10X Genomics

Descripci??n [aqu??](https://osca.bioconductor.org/unfiltered-human-pbmcs-10x-genomics.html)


*Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 (2017)*

```{r, warning=FALSE, message=FALSE }
# gene-annotation
library(scater)
rownames(sce.pbmc) <- uniquifyFeatureNames(
    rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol
)
library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86,
    keys = rowData(sce.pbmc)$ID,
    column = "SEQNAME", keytype = "GENEID"
)

# cell-detection
set.seed(100)
e.out <- emptyDrops(counts(sce.pbmc))
sce.pbmc <- sce.pbmc[, which(e.out$FDR <= 0.001)]
```

```{r , warning=FALSE, message=FALSE}
# quality-control
stats <- perCellQCMetrics(sce.pbmc,
    subsets = list(Mito = which(location == "MT"))
)
high.mito <- isOutlier(stats$subsets_Mito_percent,
    type = "higher"
)
sce.pbmc <- sce.pbmc[, !high.mito]

# normalization
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, cluster = clusters)
sce.pbmc <- logNormCounts(sce.pbmc)
```

```{r }
# variance modelling
set.seed(1001)
dec.pbmc <- modelGeneVarByPoisson(sce.pbmc)
top.pbmc <- getTopHVGs(dec.pbmc, prop = 0.1)
```

- ??C??mo se est?? modelando la relaci??n media varianza?
- ??C??mo se est??n obteniendo los HGVs?


## An??lisis de Componentes Principales

PCA es el arma principal de la reducci??n de dimensionalidad

**PCA descubre las combinaciones (lineales) de "features" que capturan la cantidad m??s grande de variaci??n**

En un PCA, la primer combinaci??n lineal (componente principal) se elige tal que permite capturar la mayor varianza a trav??s de las c??lulas. El siguiente PC se elige tal que es "ortogonal" al primero y captura la cantidad m??s grande de la variaci??n restante, y as?? sucesivamente...

### PCA aplicado a datos de scRNA-seq

Podemos realizar reducci??n de dimensionalidad al aplicar PCA en la matriz de cuentas transformadas (log-counts matrix) y restringiendo los an??lisis posteriores a los primeros PCs **(top PCs)**

* Esto puede reducir nuestro dataset de 20,000 dimensiones a, digamos, 10, sin perder demasiada informaci??n
* La t??cnica de PCA tiene muchas propiedades te??ricas bien estudiadas. 
* Hay varias formas r??pidas de realizar PCA en datasets grandes.

### Suposiciones de PCA aplicadas a los datos de scRNA-seq

* Los procesos biol??gicos afectan m??ltiples genes en una manera coordinada
* Los primeros PCs probablemente representan la estructura biol??gica dado que m??s variaci??n puede ser capturada considerando el comportamiento correlacionado de muchos genes
* Se espera que el ruido t??cnico azaroso afecte cada gen independientemente

**Consideraci??n: Los primeros PCs capturar??n "batch effects" (efectos de lote) que afectan muchos genes en una manera coordinada**


```{r , warning=FALSE, message=FALSE}
library(scran)
library(scater)
set.seed(100)
sce.zeisel <- runPCA(sce.zeisel,
    subset_row = top.zeisel
)
```


**??Estamos corriendo el an??lisis sobre todos los genes de nuestro dataset?**

Por default, **runPCA()** usa un m??todo r??pido aproximado que realiza simulaciones, por lo tanto, es necesario *'configurar la semilla'* para obtener resultados reproducibles

### Eligiendo el n??mero de PCs

*Esta elecci??n en an??loga a la elecci??n del numero de HVGs. Elegir m??s PCs evitar?? descartar se??al biol??gica a expensas de retener m??s ruido*

* Es com??n seleccionar un n??mero de PCs "razonable" pero **arbitrario** (10-50), continuar con el an??lisis y regresar para checar la robustez de los resultados en cierto rango de valores

Ahora exploraremos algunas estrategias guiadas por los datos (*data-driven*) para hacer esta selecci??n

#### Usando el punto del codo

```{r, warning=FALSE, message=FALSE, fig.dim = c(5, 4)}
library(PCAtools)
percent.var <- attr(reducedDim(sce.zeisel), "percentVar")
chosen.elbow <- PCAtools::findElbowPoint(percent.var)
plot(percent.var, xlab = "PC", ylab = "Variance explained (%)")
abline(v = chosen.elbow, col = "red")
```

Una heur??stica simple es elegir el n??mero de PCs basado en el **porcentaje de varianza explicado** por PCs sucesivos

#### Basados en la estructura de la poblaci??n

```{r }
choices <- getClusteredPCs(reducedDim(sce.zeisel))
chosen.clusters <- metadata(choices)$chosen

plot(choices$n.pcs, choices$n.clusters,
    xlab="Number of PCs", ylab="Number of clusters")
abline(a=1, b=1, col="red")
abline(v=chosen.clusters, col="grey80", lty=2)
```

Esta es una aproximaci??n heur??stica m??s sofisticada que usa el n??mero de clusters como un *proxy* del n??mero de subpoblaciones

Supongamos que esperamos *d* subpoblaciones de c??lulas, en ese caso, necesitamos *d-1* dimensiones para garantizar la separaci??n de todas las subpoblaciones

Pero... en un escenario real realmente no sabes cu??ntas poblaciones hay...

- Intenta con un rango para *d* y ??nicamente considera valores que produzcan a lo m??s *d+1* clusters
- Cuando se seleccionan m??s clusters con menos dimensiones se produce 'overclustering'
- Elige una *d* que maximice el n??mero de clusters sin caer en 'overclustering'

**Ventaja**: Es una soluci??n pragm??tica que soluciona el equilibrio sesgo-varianza en los an??lisis posteriores (especialmente clustering)

**Desventaja**: Hace suposiciones fuertes sobre la naturaleza de las diferencias biol??gicas entre los clusters, y de hecho supone la existencia de clusters, los cuales podr??an no existir en procesos biol??gicos como la diferenciaci??n

### Juntando todo

```{r }
set.seed(100)
# Compute and store the 'full' set of PCs
sce.zeisel <- runPCA(sce.zeisel, subset_row = top.zeisel)

# Can also select d and store the reduced set of PCs
# e.g., using the elbow point
reducedDim(sce.zeisel, "PCA_elbow") <- reducedDim(
    sce.zeisel, "PCA"
)[, 1:chosen.elbow]
# e.g., based on population structure
reducedDim(sce.zeisel, "PCA_clusters") <- reducedDim(
    sce.zeisel, "PCA"
)[, 1:chosen.clusters]
```

### EJERCICIO

1. Realiza un PCA para los datos **sce.pbmc**.
2. Elige el n??mero de PCs a conservar utilizando el m??todo del codo
3. Elige el n??mero de PCs a conservar utilizando la estructura de la poblaci??n
4. Agrega esta informaci??n al objeto sce.pbmc


### Usando el ruido t??cnico

```{r, warning=FALSE, message=FALSE }
library(scran)
set.seed(111001001)
denoised.pbmc <- denoisePCA(sce.pbmc,
    technical = dec.pbmc, subset.row = top.pbmc
)
```

Conserva todos los PCs hasta que el % de variaci??n explicado alcance algun l??mite (por ejemplo, basado en la estimaci??n de la variaci??n t??cnica)

**denoisePCA()** autom??ticamente selecciona el n??mero de PCs

Por default, denoisePCA() realiza algunas simulaciones, por lo tanto necesitamos *'configurar la semilla'* para obtener resultados reproducibles

```{r }
dim(reducedDim(denoised.pbmc, "PCA"))
```

La dimensionalidad del output es el l??mite inferior para el n??mero de PCs requeridos para explicar toda la variaci??n biol??gica. Lo que significa que cualquier n??mero menor de PCs definitivamente descartar?? alg??n aspecto de la se??al biol??gica

**Esto no grantiza que los PCs retenidos capturen toda la se??al biol??gica**

*Esta t??cnica usualmente retiene m??s PCs que el m??todo del punto del codo*

**scran::denoisePCA()** internamente limita el numero de PCs, por default 5-50, para evitar la selecci??n de excesivamente pocos PCs (cuando el ruido t??cnico es alto relativo al ruido biol??gico) o excesivamente muchos PCs (cuando el ruido t??cnico es demasiado bajo)

#### ??Qu?? pasa si calculamos la relaci??n media-varianza cn la funci??n modelGeneVar para el dataset sce.pbmc?

```{r }
dec.pbmc2 <- modelGeneVar(sce.pbmc)
denoised.pbmc2 <- denoisePCA(sce.pbmc,
    technical = dec.pbmc2, subset.row = top.pbmc
)
dim(reducedDim(denoised.pbmc2))
```

**scran::denoisePCA()** tiende a funcionar mejor cuando la relaci??n media-varianza refleja el ruiudo t??cnico verdadero, *i.e* estimado por **scran::modelGeneVarByPoisson()** o **scran::modelGeneVarWithSpikes()** en vez de  **scran::modelGeneVar()**

 *El dataset PBMC est?? cerca de este l??mite inferior: el ruido t??cnico es alto relativo al ruido biol??gico*



#### ??Qu?? pasa si calculamos el n??mero de PCs usando el ruido t??cnico para el dataset sce.pbmc?

```{r }
set.seed(001001001)
denoised.zeisel <- denoisePCA(sce.zeisel,
    technical = dec.zeisel, subset.row = top.zeisel
)
dim(reducedDim(denoised.zeisel))
```


*Los datos de cerebro de Zeisel est??n cerca de este l??mite superior: el ruido t??cnico es demasiado bajo*


## Reducci??n de dimensionalidad para visualizaci??n

### Motivaci??n

Clustering y otros algoritmos operaran f??cilmente sobre 10-50 (a lo m??s) PCs, pero ese n??mero es a??n demasiado para la visualizaci??n

Por lo tanto, necesitamos estrategias adicionales para la reducci??n de dimensionalidad si queremos visualizar los datos

### Visualizando con PCA

```{r, fig.dim = c(6, 4) }
plotReducedDim(sce.zeisel, dimred = "PCA")
```

```{r , fig.dim = c(6, 4)}
plotReducedDim(sce.zeisel,
    dimred = "PCA",
    colour_by = "level1class"
)
```

PCA es una t??cnica lineal, por lo tanto, no es eficiente para comprimir diferencias en m??s de 2 dimensiones en los primeros 2 PCs

### Retos y resumen de la visualizaci??n con PCA

```{r, fig.dim = c(6, 4) }
plotReducedDim(sce.zeisel,
    dimred = "PCA",
    ncomponents = 4, colour_by = "level1class"
)
```

**Ventajas:**

- PCA es predecible y no introducir?? estructura aritficial en los datos
- Es determ??nistico y robusto a cambios peque??os en los valores de entrada

**Desventajas:**

- Usualmente no la visualizaci??n no es suficiente para visualizar la naturaleza compleja de los datos de scRNA-seq

### Visualizaci??n con t-SNE

```{r, fig.dim = c(5, 4) }
set.seed(00101001101)
sce.zeisel <- runTSNE(sce.zeisel, dimred = "PCA")
plotReducedDim(sce.zeisel, dimred = "TSNE", colour_by = "level1class")
```

*t-stochastic neighbour embedding (t-SNE)* es la visualizaci??n por excelencia de datos de scRNA-seq. **Intenta encontrar una representaci??n (no-lineal) de los datos usando pocas dimensiones que preserve las distancias entre cada punto y sus vecinos en el espacio multi-dimensional**

#### Retos de la visualizaci??n con t-SNE

```{r, fig.dim = c(6, 4) }
set.seed(100)
sce.zeisel <- runTSNE(sce.zeisel,
    dimred = "PCA",
    perplexity = 30
)
plotReducedDim(sce.zeisel,
    dimred = "TSNE",
    colour_by = "level1class"
)
```

#### Preguntas

- ??Qu?? pasa si vuelves a correr **runTSNE()** sin especificar la semilla?

- ??Qu?? pasa si especificas la semilla pero cambias el valor del par??metro *perplexity*?


#### Continuando


- Baja perplejidad favorece la resoluci??n de la estructura fina, posiblemente al grado de que la visualizaci??n parece rudio random.


```{r, fig.dim = c(6, 4) }
set.seed(100)

sce.zeisel <- runTSNE(sce.zeisel, dimred = "PCA", perplexity = 5)
p1 <- plotReducedDim(sce.zeisel, dimred = "TSNE", colour_by = "level1class")

sce.zeisel <- runTSNE(sce.zeisel, dimred = "PCA", perplexity = 20)
p2 <- plotReducedDim(sce.zeisel, dimred = "TSNE", colour_by = "level1class")

sce.zeisel <- runTSNE(sce.zeisel, dimred = "PCA", perplexity = 80)
p3 <- plotReducedDim(sce.zeisel, dimred = "TSNE", colour_by = "level1class")


gridExtra::grid.arrange(p1, p2, p3, nrow =1)
```



El siguiente [foro](http://distill.pub/2016/misread-tsne/) discute la selecci??n de par??metros para t-SNE con cierta profundidad


- No sobreinterpretes los resultados de t-SNE como un 'mapa' de las identidades de las c??lulas individuales
- Algunos componentes aleatorios y la selecci??n de par??metors cambiar??n la visualizaci??n
- La interpretaci??n puede ser enga??ada por el tama??o y posici??n de los clusters
- t-SNE infla clusters densos y comprime clusters escasos
- t-SNE no est?? obligado a preservar las localizaciones relativas de clusters no-vecinos (no puedes interpretar distancias no locales)

**A??n as??: t-SNE es una herramienta probada para visualizaci??n general de datos de scRNA-seq y sigue siendo muy popular**

### Visualizaci??n con UMAP

*Uniform manifold approximation and project (UMAP)* es una alternativa a t-SNE

As?? como t-SNE, UMAP **intenta encontrar una representaci??n (no lineal) de pocas dimensiones de los datos que preserve las distancias entre cada puntos y sus vecinos en el espacio multi-dimensional**

t-SNE y UMAP est??n basados en diferentes teor??as matem??ticas

```{r, fig.dim = c(6, 4) }
set.seed(1100101001)
sce.zeisel <- runUMAP(sce.zeisel, dimred = "PCA")
plotReducedDim(sce.zeisel,
    dimred = "UMAP",
    colour_by = "level1class"
)
```

Comparado con t-SNE:

- UMAP tiende a encontrar clusters visualmente m??s compactos
- Intenta preservar m??s de la estructura global que t-SNE
- Tiende a ser m??s r??pido que t-SNE, lo cual puede ser importante para datasets grandes. La diferencia desaparece cuando se aplican sobre los primeros PCs

#### Retos de la visualizaci??n con UMAP

```{r, fig.dim = c(6, 4) }

set.seed(100)
sce.zeisel <- runUMAP(sce.zeisel,
    dimred = "PCA",
    n_neighbors = 15
)
plotReducedDim(sce.zeisel,
    dimred = "UMAP",
    colour_by = "level1class"
)
```

#### Preguntas

- ??Qu?? pasa si vuelves a correr **runUMAP()** sin especificar la semilla?

- ??Qu?? pasa si especificas la semilla pero cambias el valor del par??metro *n_neighbors*?

#### Continuando

<div>
<p style = 'text-align:center;'>
<img src="img/umap.png" width="800px">
</p>
</div>

- Igual que para t-SNE, es necesario configurar una semilla y diferentes valores para los par??metros cambiar??n la visualizaci??n

- Si el valor para los par??metros *n_neighbors* o *min_dist* es demasiado bajo entonces el ruido aleatorio se interpretar?? como estructura de alta-resoluci??n, si son demasiado altos entonces se perder?? la estructura fina

**TIP: Trata un rango de valores para cada par??metro para asegurarte de que no comprometen ninguna de las conclusiones derivadas de la gr??fica UMAP o t-SNE**

### Interpretando las gr??ficas

**Recuerda:**


- Reducci??n de dimensionalidad para la visualizaci??n de los datos necesariamente involucra descartar informaci??n y distorsionar las distancias entre las c??lulas

- No sobre interpretes las gr??ficas bonitas

### Resumen y recomendaciones

- Las gr??ficas de t-SNE y UMAP son herramientas diagn??stico importantes, por ejemplo: para checar si dos clusters son realmente subclusters vecinos o si un cluster puede ser dividido en m??s de un cluster

- Es debatible cual visualizaci??n, t-SNE o UMAP, es m??s ??til o est??ticamente agradable.

- Est?? bien elegir aqu??lla que funcione mejor para tu an??lisis (tomando en cuenta que tratar??s la gr??fica ??nicamente como una herramienta de visualizaci??n/diagn??stico y que no llegar??s a ninguna conclusi??n fuerte basado ??nicamente en la gr??fica )

## Donde estamos


<div>
<p style = 'text-align:center;'>
<img src="img/resumen.png" width="500px" heigth="400px">
</p>
</div>

## Detalles de la sesi??n de R

```{r}
## Informaci??n de la sesi??n de R
Sys.time()
proc.time()
options(width = 120)
sessioninfo::session_info()
```

## Patrocinadores {-}

Agradecemos a nuestros patrocinadores:

<a href="https://comunidadbioinfo.github.io/es/post/cs_and_s_event_fund_award/#.YJH-wbVKj8A"><img src="https://comunidadbioinfo.github.io/post/2021-01-27-cs_and_s_event_fund_award/spanish_cs_and_s_award.jpeg" width="400px" align="center"/></a>

<a href="https://www.r-consortium.org/"><img src="https://www.r-consortium.org/wp-content/uploads/sites/13/2016/09/RConsortium_Horizontal_Pantone.png" width="400px" align="center"/></a>
